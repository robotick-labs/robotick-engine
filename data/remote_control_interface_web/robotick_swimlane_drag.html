<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Robotick Swimlane Graph</title>
  <link rel="stylesheet" href="css/common.css" />
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <style>
    body {
      display: block;
    }

    svg {
      width: 98vw;
      height: 90vh;
      display: block;
    }

    .swimlane {
      fill: #1a1a1a;
      stroke: #333;
    }

    .workload {
      fill: #2266aa;
      stroke: #88ccff;
      stroke-width: 2;
      rx: 6;
      cursor: move;
    }

    .workload-node text {
      fill: #bbe0fc;
      font-size: 12px;
      pointer-events: none;
    }

    .connection {
      fill: none;
      stroke: #ffaa00;
      stroke-width: 2;
      stroke-dasharray: 4 4;
      animation: pulse 2s infinite linear;
    }

    @keyframes pulse {
      to {
        stroke-dashoffset: -8;
      }
    }

    .label {
      fill: white;
      font-size: 10px;
    }

    .group {
      fill: none;
      stroke: #33cc66;
      stroke-width: 2;
      stroke-dasharray: 6 4;
    }

    #info-box {
      display: block;
      background-color: #222;
      color: #ccc;
      font-family: monospace;
      font-size: 10px;
      padding: 6px 12px;
      white-space: pre-wrap;
      overflow-y: auto;
      height: 80px;
      width: 95vw;
      box-sizing: border-box;
      border-top: 1px solid #444;
    }
  </style>
</head>

<body>
  <svg id="graph" viewBox="0 0 1000 400">
    <defs></defs>
  </svg>

  <div id="info-box">Swimlane graph loaded. No errors.
    cd ~/dev/robotick/robotick-knitware/robotick-engine/data/remote_control_interface_web
    python3 -m http.server 8000</div>

  <script>
    const svg = document.getElementById('graph');
    const nodeSize = { width: 140, height: 40 };

    // Create SVG layers
    const swimlaneLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const groupLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const connectionsLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodeLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    swimlaneLayer.setAttribute('id', 'swimlanes-layer');
    groupLayer.setAttribute('id', 'groups-layer');
    connectionsLayer.setAttribute('id', 'connections-layer');
    nodeLayer.setAttribute('id', 'nodes-layer');

    svg.appendChild(swimlaneLayer);
    svg.appendChild(groupLayer);
    svg.appendChild(connectionsLayer);
    svg.appendChild(nodeLayer);

    async function loadModel() {
      const res = await fetch('models/advanced-robot-model.yaml');
      const text = await res.text();
      const data = jsyaml.load(text);
      if (!data || !data.model || !data.model.core) {
        throw new Error('Invalid model structure: expecting model.core in YAML');
      }
      return data.model.core;
    }

    function drawSwimlanes(count, height) {
      for (let i = 0; i < count; i++) {
        const y = i * height;
        const lane = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        lane.classList.add('swimlane');
        lane.setAttribute('x', 0);
        lane.setAttribute('y', y);
        lane.setAttribute('width', 1000);
        lane.setAttribute('height', height);
        swimlaneLayer.appendChild(lane);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.classList.add('label');
        label.setAttribute('x', 10);
        label.setAttribute('y', y + 20);
        label.textContent = `Thread ${i + 1}`;
        swimlaneLayer.appendChild(label);
      }
    }

    function createNode(id, x, y) {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('workload-node');
      g.setAttribute('id', id);
      g.setAttribute('transform', `translate(${x},${y})`);

      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.classList.add('workload');
      rect.setAttribute('width', nodeSize.width);
      rect.setAttribute('height', nodeSize.height);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 10);
      text.setAttribute('y', 25);
      text.textContent = id;

      g.appendChild(rect);
      g.appendChild(text);
      nodeLayer.appendChild(g);

      makeDraggable(g);
    }

    function createGroupBox(id, x, y, w, h) {
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.classList.add('group');
      rect.setAttribute('x', x);
      rect.setAttribute('y', y);
      rect.setAttribute('width', w);
      rect.setAttribute('height', h);
      groupLayer.appendChild(rect);
    }

    function makeDraggable(node) {
      let offsetX = 0, offsetY = 0;
      const pt = svg.createSVGPoint();
      const toSvgCoords = e => {
        pt.x = e.clientX;
        pt.y = e.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
      };
      node.addEventListener('mousedown', e => {
        const start = toSvgCoords(e);
        const matrix = node.transform.baseVal.getItem(0).matrix;
        offsetX = start.x - matrix.e;
        offsetY = start.y - matrix.f;
        const onMouseMove = ev => {
          const { x, y } = toSvgCoords(ev);
          node.setAttribute('transform', `translate(${x - offsetX},${y - offsetY})`);
          updateConnections(currentConnections);
        };
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', () => window.removeEventListener('mousemove', onMouseMove), { once: true });
      });
    }

    let currentConnections = [];

    function updateConnections(conns) {
      currentConnections = conns;
      while (connectionsLayer.firstChild) {
        connectionsLayer.removeChild(connectionsLayer.firstChild);
      }

      conns.forEach(c => {
        const from = document.getElementById(c.from);
        const to = document.getElementById(c.to);
        if (!from || !to) return;
        const fm = from.transform.baseVal.getItem(0).matrix;
        const tm = to.transform.baseVal.getItem(0).matrix;
        const x1 = fm.e + nodeSize.width;
        const y1 = fm.f + nodeSize.height / 2;
        const x2 = tm.e;
        const y2 = tm.f + nodeSize.height / 2;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.classList.add('connection');
        path.setAttribute('d', `M${x1},${y1} C${x1 + 40},${y1} ${x2 - 40},${y2} ${x2},${y2}`);
        connectionsLayer.appendChild(path);
      });
    }

    (async () => {
      try {
        const model = await loadModel();
        const rootId = model.root;
        const root = model.workloads.find(w => w.id === rootId);
        if (!root || !root.children) throw new Error('Root with children not found');

        const lanes = root.children.length;
        const laneHeight = 400 / lanes;
        drawSwimlanes(lanes, laneHeight);

        const startX = 100;
        const spacing = 180;
        const offsetY = (laneHeight - nodeSize.height) / 2;

        root.children.forEach((childId, idx) => {
          const workload = model.workloads.find(w => w.id === childId);
          const y = idx * laneHeight + offsetY;
          if (workload.children) {
            workload.children.forEach((subId, j) => {
              createNode(subId, startX + j * spacing, y);
            });
            const boxWidth = workload.children.length * spacing + 20;
            createGroupBox(workload.id, startX - 10, y - 10, boxWidth, nodeSize.height + 20);
          } else {
            createNode(childId, startX, y);
          }
        });

        const conns = model.data_connections.map(dc => ({
          from: dc.from.split('.')[0],
          to: dc.to.split('.')[0]
        }));
        updateConnections(conns);
      } catch (err) {
        console.error('Error loading or rendering model:', err);
      }
    })();
  </script>
</body>

</html>